<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AI å‰µä¸–ç¹ª (åè©ç‰ˆ)</title>
    
    <style>
        /* CSS å€åŸŸ */
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f0f0f0; margin: 0; padding: 10px; box-sizing: border-box; }
        h1 { color: #333; text-align: center; margin-bottom: 10px; }
        .toolbar { display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 10px; background-color: #ffffff; padding: 10px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 15px; width: 95%; max-width: 800px; box-sizing: border-box;}
        button { padding: 8px 12px; border: none; background-color: #3498db; color: white; font-size: 16px; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; }
        button:hover:not(:disabled) { background-color: #2980b9; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        #startGameBtn { background-color: #2ecc71; } #startGameBtn:hover:not(:disabled) { background-color: #27ae60; }
        #drawerTools button { background-color: #9b59b6; }
        #drawerTools button:hover:not(:disabled) { background-color: #8e44ad; }
        #eraserBtn.active { background-color: #e74c3c; box-shadow: 0 0 5px 2px #e74c3c; }
        .hidden { display: none !important; }
        #canvas-container { width: 95%; max-width: 800px; margin: 0 auto; aspect-ratio: 16 / 9; position: relative; border: 2px solid #00c2a8; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border-radius: 4px; }
        #drawingCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #ffffff; cursor: crosshair; touch-action: none; }
        #game-ui { display: flex; justify-content: space-between; width: 95%; max-width: 800px; margin-top: 15px; gap: 15px; flex-wrap: wrap; }
        #game-status-panel, #chat-panel { flex-basis: 100%; flex-grow: 1; display: flex; flex-direction: column; min-width: 280px;}
        .panel-title { font-weight: bold; margin-bottom: 5px; color: #555; }
        #status-box, #word-to-draw-box { background-color: #fff; padding: 10px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); font-size: 1.1em; text-align: center; margin-bottom: 10px; min-height: 24px; word-wrap: break-word; }
        #word-to-draw-box { color: #d35400; font-weight: bold; }
        #chat-messages { background-color: #fff; height: 150px; padding: 10px; border-radius: 5px; overflow-y: scroll; margin-bottom: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        #chat-messages div { margin-bottom: 5px; word-wrap: break-word; }
        #chat-messages .system { font-style: italic; color: #888; }
        #chat-messages .guess .player-name { font-weight: bold; }
        #chat-messages .correct .player-name { color: #2ecc71; font-weight: bold; }
        #chat-messages .correct { color: #2ecc71; animation: pulse 0.5s 2; }
        #guess-form { display: flex; }
        #guess-input { flex-grow: 1; border: 1px solid #ccc; border-radius: 5px 0 0 5px; padding: 8px; }
        #guess-btn { border-radius: 0 5px 5px 0; }
        #timer { font-size: 1.5em; font-weight: bold; color: #e67e22; background-color: #fff; padding: 5px 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .times-up { color: #e74c3c; }
        #nicknameDisplay { font-size: 1em; color: #34495e; padding: 5px 10px; background-color: #ecf0f1; border-radius: 5px; }
        #top-right-corner { position: fixed; top: 10px; right: 10px; display: flex; flex-direction: column; align-items: flex-end; gap: 10px; z-index: 1000; }
        #online-counter { background-color: rgba(0, 0, 0, 0.6); color: white; padding: 8px 12px; border-radius: 20px; font-size: 1em; font-weight: bold; display: flex; align-items: center; gap: 5px; }
        .online-dot { width: 10px; height: 10px; background-color: #2ecc71; border-radius: 50%; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    </style>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
</head>
<body>
    <!-- HTML å…§å®¹ -->
    <div id="top-right-corner">
        <div id="online-counter"><span class="online-dot"></span><span id="online-count">1</span> äººåœ¨ç·š</div>
    </div>

    <h1>AI å‰µä¸–ç¹ª ğŸ¨</h1>
    <div class="toolbar">
        <button id="startGameBtn">æˆç‚ºå‰µä½œè€…ï¼</button><button id="changeNameBtn">æ›´æ”¹æš±ç¨±</button><span id="nicknameDisplay"></span><div id="timer">--</div><label for="colorPicker">é¡è‰²:</label><input type="color" id="colorPicker" value="#000000"><label for="lineWidth">ç²—ç´°:</label><input type="range" id="lineWidth" min="1" max="50" value="5"><div id="drawerTools" class="hidden"><button id="eraserBtn">æ©¡çš®æ“¦</button><button id="clearCanvasBtn">æ¸…ç©ºç•«å¸ƒ</button></div>
    </div>
    
    <div id="canvas-container"><canvas id="drawingCanvas"></canvas></div>
    <div id="game-ui">
        <div id="game-status-panel"><div class="panel-title">éŠæˆ²ç‹€æ…‹</div><div id="status-box"></div><div class="panel-title">æœ¬å›åˆè¬åº•</div><div id="word-to-draw-box"></div></div>
        <div id="chat-panel"><div class="panel-title">èŠå¤©èˆ‡çŒœé¡Œ</div><div id="chat-messages"></div><form id="guess-form"><input type="text" id="guess-input" placeholder="è¼¸å…¥çŒœæ¸¬æˆ–è¨Šæ¯..." autocomplete="off"><button type="submit" id="guess-btn">é€å‡º</button></form></div>
    </div>

    <script>
        // JavaScript ç¨‹å¼ç¢¼
        const firebaseConfig = { apiKey: "AIzaSyC2yDx3yu7yj_mQWYlI6Ivs9b2qgdSEh6s",
  authDomain: "ai-drawing-game.firebaseapp.com",
  projectId: "ai-drawing-game",
  storageBucket: "ai-drawing-game.firebasestorage.app",
  messagingSenderId: "918732328621",
  appId: "1:918732328621:web:3d6f8e42cbc64e3d6a0024",
  measurementId: "G-6WBPNSYRRJ"
 };
        try { firebase.initializeApp(firebaseConfig); } catch (e) { console.error("Firebase åˆå§‹åŒ–å¤±æ•—ï¼", e); alert("Firebase åˆå§‹åŒ–å¤±æ•—ï¼è«‹æª¢æŸ¥ F12 Consoleã€‚"); }
        
        const database = firebase.database();
        const gameStateRef = database.ref('gameState');
        const drawingsRef = database.ref('drawings');
        const messagesRef = database.ref('messages');
        const connectionsRef = database.ref('connections');
        const presenceRef = database.ref('.info/connected');

        // --- â˜…â˜…â˜… NEW: å…¨æ–°åè©é¡Œåº« (è¶…é100é¡Œ) â˜…â˜…â˜… ---
        const wordList = [
            // å‹•ç‰©
            "è²“", "ç‹—", "å…”å­", "ç…å­", "è€è™", "å¤§è±¡", "é•·é ¸é¹¿", "çŒ´å­", "ç†Š", "é­š", "é³¥", "è´è¶", "è›‡", "çƒé¾œ", "ä¼éµ", "é´¨å­", "é›", "è±¬", "ç‰›", "ç¾Š", "è€é¼ ", "é¦¬", "é¾", "é¯¨é­š", "æµ·è±š",
            // æ°´æœ
            "è˜‹æœ", "é¦™è•‰", "æ©˜å­", "è‰è“", "è‘¡è„", "è¥¿ç“œ", "é³³æ¢¨", "æª¸æª¬", "èŠ’æœ", "æ«»æ¡ƒ", "æ¡ƒå­", "æ¢¨å­",
            // æ—¥å¸¸ç”¨å“
            "æ‰‹æ©Ÿ", "é›»è¦–", "é›»è…¦", "æ¡Œå­", "æ¤…å­", "åºŠ", "ç‡ˆ", "é‘°åŒ™", "æ™‚é˜", "çœ¼é¡", "é›¨å‚˜", "ç‰™åˆ·", "å‰ªåˆ€", "æ›¸", "æ¯å­", "ç¢—", "ç­·å­", "æ¹¯åŒ™", "æ²™ç™¼", "å†°ç®±",
            // é£Ÿç‰©èˆ‡é£²æ–™
            "æ¼¢å ¡", "æŠ«è–©", "éºµåŒ…", "è›‹ç³•", "å†°æ·‡æ·‹", "è–¯æ¢", "é£¯", "éºµ", "å’–å•¡", "ç‰›å¥¶", "æœæ±", "é¤…ä¹¾", "å·§å…‹åŠ›", "ç”œç”œåœˆ",
            // è¡£ç‰©
            "å¸½å­", "é‹å­", "è¥ªå­", "è¤²å­", "è£™å­", "æ‰‹å¥—", "åœå·¾", "å¤–å¥—", "Tæ¤",
            // è‡ªç„¶æ™¯è§€
            "å¤ªé™½", "æœˆäº®", "æ˜Ÿæ˜Ÿ", "æ¨¹", "èŠ±", "é›²", "å±±", "æ²³", "å½©è™¹", "ç«å±±", "ç€‘å¸ƒ", "æ²™æ¼ ", "æµ·æ´‹",
            // äº¤é€šå·¥å…·
            "æ±½è»Š", "é£›æ©Ÿ", "ç«è»Š", "èˆ¹", "è…³è¸è»Š", "å…¬è»Š", "æ©Ÿè»Š", "ç«ç®­", "è¨ˆç¨‹è»Š",
            // å»ºç¯‰/åœ°é»
            "æˆ¿å­", "å­¸æ ¡", "æ©‹", "åŸå ¡", "é†«é™¢", "é‡‘å­—å¡”", "æ•™å ‚", "ç‡ˆå¡”",
            // å…¶ä»–
            "å‰ä»–", "é‹¼ç´", "é¼“", "å°æç´", "è¶³çƒ", "ç±ƒçƒ", "æ£’çƒ", "åœ°çƒ", "æ©Ÿå™¨äºº"
        ];


        window.addEventListener('load', () => {
            // --- å–å¾—æ‰€æœ‰ UI å…ƒç´  ---
            const onlineCount = document.getElementById('online-count');
            const timerDisplay = document.getElementById('timer'); const changeNameBtn = document.getElementById('changeNameBtn'); const nicknameDisplay = document.getElementById('nicknameDisplay');
            const drawerTools = document.getElementById('drawerTools'); const eraserBtn = document.getElementById('eraserBtn'); const clearCanvasBtn = document.getElementById('clearCanvasBtn');
            const canvasContainer = document.getElementById('canvas-container'); const canvas = document.getElementById('drawingCanvas'); const ctx = canvas.getContext('2d'); const startGameBtn = document.getElementById('startGameBtn'); const statusBox = document.getElementById('status-box'); const wordToDrawBox = document.getElementById('word-to-draw-box'); const chatMessages = document.getElementById('chat-messages'); const guessForm = document.getElementById('guess-form'); const guessInput = document.getElementById('guess-input'); const guessBtn = document.getElementById('guess-btn'); const colorPicker = document.getElementById('colorPicker'); const lineWidthInput = document.getElementById('lineWidth');

            let drawingHistory = [], localGameState = {}, timerInterval = null, isErasing = false;
            let myPlayerId = 'player_' + Math.random().toString(36).substr(2, 9);
            let myNickname = '';

            // --- åœ¨ç·šäººæ•¸ç³»çµ± ---
            function setupPresenceSystem() {
                const myConnectionRef = connectionsRef.child(myPlayerId);
                presenceRef.on('value', (snapshot) => {
                    if (snapshot.val() === true) {
                        myConnectionRef.set(true);
                        myConnectionRef.onDisconnect().remove();
                    }
                });
                connectionsRef.on('value', (snapshot) => {
                    const count = snapshot.numChildren();
                    onlineCount.textContent = count;
                });
            }

            // --- ç©å®¶èˆ‡éŠæˆ²é‚è¼¯ ---
            function initializeUser() { let storedName = localStorage.getItem('playerNickname'); if (!storedName || storedName.trim() === '') { myNickname = 'è¨ªå®¢' + Math.floor(Math.random() * 1000); localStorage.setItem('playerNickname', myNickname); } else { myNickname = storedName; } nicknameDisplay.textContent = `æ‚¨å¥½, ${myNickname}`; }
            function changeNickname() { const oldNickname = myNickname; const newNickname = prompt("è«‹è¼¸å…¥æ‚¨çš„æ–°æš±ç¨±ï¼š", oldNickname); if (newNickname === null) { return; } if (newNickname.trim() === '') { alert("æš±ç¨±ä¸èƒ½ç‚ºç©ºï¼"); return; } if (newNickname.trim() === oldNickname) { return; } myNickname = newNickname.trim(); localStorage.setItem('playerNickname', myNickname); nicknameDisplay.textContent = `æ‚¨å¥½, ${myNickname}`; messagesRef.push({ type: 'system', text: `ç©å®¶ "${oldNickname}" å·²å°‡æš±ç¨±æ›´æ”¹ç‚º "${myNickname}"` }); }
            changeNameBtn.addEventListener('click', changeNickname);
            eraserBtn.addEventListener('click', () => { isErasing = !isErasing; eraserBtn.classList.toggle('active', isErasing); });
            clearCanvasBtn.addEventListener('click', () => { if (confirm('ç¢ºå®šè¦æ¸…ç©ºæ‚¨ç•¶å‰çš„ç•«ä½œå—ï¼Ÿ')) { drawingsRef.remove(); } });
            colorPicker.addEventListener('input', () => { isErasing = false; eraserBtn.classList.remove('active'); });
            function setGameState(newState) { gameStateRef.set(newState); }
            function checkAndResetStaleGame(state) { if (state.status === 'drawing' && state.roundEndTime && Date.now() > state.roundEndTime + 15000) { console.log("åµæ¸¬åˆ°éæœŸçš„éŠæˆ²ï¼Œæ­£åœ¨è‡ªå‹•é‡ç½®..."); messagesRef.push({ type: 'system', text: `ä¸Šä¸€å›åˆå·²éæœŸï¼ŒéŠæˆ²å·²è‡ªå‹•é‡ç½®ã€‚` }); setGameState({ status: 'waiting' }); drawingsRef.remove(); return true; } return false; }
            gameStateRef.on('value', (snapshot) => { const state = snapshot.val() || { status: 'waiting' }; if (checkAndResetStaleGame(state)) { return; } localGameState = state; updateUI(state); if (timerInterval) clearInterval(timerInterval); if (state.status === 'drawing' && state.roundEndTime) { timerInterval = setInterval(() => { const secondsLeft = Math.round((state.roundEndTime - Date.now()) / 1000); if (secondsLeft >= 0) { timerDisplay.textContent = `â³ ${secondsLeft}`; timerDisplay.classList.remove('times-up'); } else { timerDisplay.textContent = "æ™‚é–“åˆ°ï¼"; timerDisplay.classList.add('times-up'); clearInterval(timerInterval); if (localGameState.drawer === myPlayerId) { const finalState = localGameState; finalState.status = 'timesup'; setGameState(finalState); } } }, 1000); } });
            
            function updateUI(state) {
                const drawerName = state.drawerNickname || (state.drawer || '').substr(0, 10);
                const winnerName = state.winnerNickname || (state.winner || '').substr(0, 10);
                const currentWord = state.word || '';
                const isMyTurn = state.status === 'drawing' && state.drawer === myPlayerId;

                drawerTools.classList.toggle('hidden', !isMyTurn);
                if (!isMyTurn && isErasing) {
                    isErasing = false;
                    eraserBtn.classList.remove('active');
                }

                if (isMyTurn) {
                    statusBox.textContent = "è¼ªåˆ°ä½ ç•«äº†ï¼è®“å¤§å®¶çŒœçŒœçœ‹å§ï¼";
                    wordToDrawBox.textContent = `ä½ è¦ç•«çš„æ˜¯ï¼š${currentWord}`;
                    startGameBtn.disabled = true;
                } else if (state.status === 'drawing') {
                    statusBox.textContent = `è¼ªåˆ° ${drawerName} ç•«åœ–ï¼Œå¿«ä¾†çŒœï¼`;
                    wordToDrawBox.textContent = currentWord.replace(/[^\s]/g, '_ ');
                    startGameBtn.disabled = true;
                } else if (state.status === 'reveal') {
                    statusBox.innerHTML = `<b>${winnerName}</b> çŒœå°äº†ï¼ç­”æ¡ˆæ˜¯ï¼š<b>${currentWord}</b>`;
                    wordToDrawBox.textContent = `ç­”æ¡ˆï¼š${currentWord}`;
                    startGameBtn.disabled = false;
                    timerDisplay.textContent = "--";
                } else if (state.status === 'timesup') {
                    statusBox.innerHTML = `æ™‚é–“åˆ°ï¼æ²’æœ‰äººçŒœå°ã€‚ç­”æ¡ˆæ˜¯ï¼š<b>${currentWord}</b>`;
                    wordToDrawBox.textContent = `ç­”æ¡ˆï¼š${currentWord}`;
                    startGameBtn.disabled = false;
                    timerDisplay.textContent = "æ™‚é–“åˆ°ï¼";
                } else {
                    statusBox.textContent = "ç­‰å¾…å‰µä½œè€…é–‹å§‹æ–°å›åˆ...";
                    wordToDrawBox.textContent = "";
                    startGameBtn.disabled = false;
                    timerDisplay.textContent = "--";
                }

                // --- é˜²å¼Šé‚è¼¯ ---
                const isGuessingTime = state.status === 'drawing';
                if (isMyTurn) {
                    guessInput.disabled = true;
                    guessBtn.disabled = true;
                    guessInput.placeholder = "ä½ æ˜¯å‰µä½œè€…ï¼Œè«‹ç”¨ç•«çš„ï¼ğŸ¨";
                } else if (isGuessingTime) {
                    guessInput.disabled = false;
                    guessBtn.disabled = false;
                    guessInput.placeholder = "è¼¸å…¥çŒœæ¸¬æˆ–è¨Šæ¯...";
                } else {
                    guessInput.disabled = true;
                    guessBtn.disabled = true;
                    guessInput.placeholder = "ç¾åœ¨ä¸æ˜¯çŒœé¡Œæ™‚é–“...";
                }
            }

            startGameBtn.addEventListener('click', () => { 
                drawingsRef.remove(); 
                messagesRef.remove(); 
                const randomWord = wordList[Math.floor(Math.random() * wordList.length)]; 
                // --- â˜…â˜…â˜… éŠæˆ²æ™‚é–“ä¿®æ”¹ç‚º 90 ç§’ â˜…â˜…â˜… ---
                setGameState({ status: 'drawing', drawer: myPlayerId, drawerNickname: myNickname, word: randomWord, roundEndTime: Date.now() + 90000 }); 
            });

            guessForm.addEventListener('submit', (e) => { e.preventDefault(); const guessText = guessInput.value.trim(); if (guessText === '' || localGameState.status !== 'drawing') return; if (guessText === localGameState.word) { const finalState = localGameState; finalState.status = 'reveal'; finalState.winner = myPlayerId; finalState.winnerNickname = myNickname; setGameState(finalState); messagesRef.push({ type: 'correct', nickname: myNickname, text: `çŒœå°äº†ï¼` }); } else { messagesRef.push({ type: 'guess', nickname: myNickname, text: guessText }); } guessInput.value = ''; });
            messagesRef.on('child_added', (snapshot) => { const msg = snapshot.val(); if(!msg || !msg.type) return; const msgElement = document.createElement('div'); msgElement.classList.add(msg.type); if (msg.type === 'system') { msgElement.textContent = msg.text; } else { const playerNameSpan = document.createElement('span'); playerNameSpan.classList.add('player-name'); playerNameSpan.textContent = `${msg.nickname || 'åŒ¿å'}: `; msgElement.appendChild(playerNameSpan); msgElement.append(msg.text); } chatMessages.appendChild(msgElement); chatMessages.scrollTop = chatMessages.scrollHeight; });
            
            // --- ç¹ªåœ–ç›¸é—œå‡½å¼ ---
            function draw(e) { if (!isDrawing || localGameState.status !== 'drawing' || localGameState.drawer !== myPlayerId) return; e.preventDefault(); const [currentX, currentY] = getCoords(e); const drawColor = isErasing ? '#ffffff' : colorPicker.value; const drawWidth = lineWidthInput.value; const lineData = { startX_norm: lastX / canvas.width, startY_norm: lastY / canvas.height, endX_norm: currentX / canvas.width, endY_norm: currentY / canvas.height, color: drawColor, width: drawWidth }; drawingsRef.push(lineData); [lastX, lastY] = [currentX, currentY]; }
            let isDrawing = false, lastX = 0, lastY = 0;
            function resizeCanvas() { canvas.width = canvasContainer.offsetWidth; canvas.height = canvasContainer.offsetHeight; redrawAll(); }
            function redrawAll() { ctx.clearRect(0, 0, canvas.width, canvas.height); drawingHistory.forEach(drawLineOnCanvas); }
            function drawLineOnCanvas(data) { if(!data) return; const startX = data.startX_norm * canvas.width; const startY = data.startY_norm * canvas.height; const endX = data.endX_norm * canvas.width; const endY = data.endY_norm * canvas.height; ctx.strokeStyle = data.color; ctx.lineWidth = data.width; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); ctx.stroke(); }
            drawingsRef.on('child_added', (snapshot) => { const data = snapshot.val(); drawingHistory.push(data); drawLineOnCanvas(data); });
            drawingsRef.on('child_removed', () => { drawingHistory = []; ctx.clearRect(0, 0, canvas.width, canvas.height); });
            function startDrawing(e) { isDrawing = true; [lastX, lastY] = getCoords(e); }
            function stopDrawing() { isDrawing = false; }
            function getCoords(e) { if (e.touches && e.touches.length > 0) { const rect = canvas.getBoundingClientRect(); return [e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top]; } return [e.offsetX, e.offsetY]; }
            
            // --- äº‹ä»¶ç›£è½ç¶å®š ---
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousedown', startDrawing); canvas.addEventListener('mousemove', draw); canvas.addEventListener('mouseup', stopDrawing); canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('touchstart', startDrawing); canvas.addEventListener('touchmove', draw); canvas.addEventListener('touchend', stopDrawing);
            
            // --- é é¢è¼‰å…¥æ™‚çš„åˆå§‹åŒ–é †åº ---
            initializeUser();
            setupPresenceSystem();
            updateUI({ status: 'waiting' });
            resizeCanvas();
        });
    </script>
</body>
</html>